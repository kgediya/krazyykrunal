<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>SkyHi Immersive Receiver</title>
    <style>
        :root {
            --text: #f8f0de;
            --muted: rgba(248, 240, 222, 0.75);
            --line: rgba(255, 215, 138, 0.22);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            color: var(--text);
            font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            background: #000;
        }

        body {
            background:
                radial-gradient(circle at 50% 16%, rgba(255, 193, 76, 0.14), transparent 38%),
                radial-gradient(circle at 82% 28%, rgba(235, 153, 38, 0.1), transparent 34%),
                radial-gradient(circle at 18% 82%, rgba(255, 222, 166, 0.06), transparent 38%),
                radial-gradient(ellipse at 50% 100%, rgba(255, 187, 71, 0.08), transparent 46%),
                linear-gradient(180deg, #090909 0%, #030303 42%, #020202 100%);
        }

        #scene {
            position: fixed;
            inset: 0;
        }

        .hud {
            position: fixed;
            top: 14px;
            left: 14px;
            right: 14px;
            z-index: 10;
            pointer-events: none;
        }

        .panel {
            pointer-events: auto;
            width: min(720px, 100%);
            background: linear-gradient(180deg, rgba(255, 235, 196, 0.12), rgba(255, 255, 255, 0.04));
            border: 1px solid var(--line);
            border-radius: 16px;
            padding: 12px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 14px 28px rgba(0, 0, 0, 0.34), inset 0 1px 0 rgba(255, 235, 196, 0.1);
        }

        .title {
            font-size: 12px;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: rgba(255, 226, 171, 0.92);
        }

        .subtitle {
            margin-top: 4px;
            font-size: 12px;
            color: var(--muted);
        }

        .controls {
            margin-top: 10px;
            display: grid;
            grid-template-columns: 1fr auto auto auto;
            gap: 8px;
            align-items: center;
        }

        input, button, a {
            height: 38px;
            border-radius: 999px;
            border: 1px solid rgba(255, 214, 138, 0.2);
            background: rgba(255, 214, 138, 0.08);
            color: var(--text);
            font-size: 13px;
            text-decoration: none;
        }

        input {
            width: 100%;
            padding: 0 12px;
            outline: none;
        }

        input:focus {
            border-color: rgba(255, 220, 160, 0.35);
            box-shadow: 0 0 0 3px rgba(243, 207, 132, 0.1);
        }

        button, .link-btn {
            padding: 0 12px;
            cursor: pointer;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        button:hover, .link-btn:hover {
            background: rgba(255, 214, 138, 0.14);
        }

        .status {
            margin-top: 8px;
            font-size: 12px;
            color: rgba(255, 232, 194, 0.9);
        }

        .legend {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 12px;
            color: var(--muted);
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
            vertical-align: middle;
        }

        .dot.gold { background: #ffc862; }
        .dot.rose { background: #ff9bad; }

        #toast {
            position: fixed;
            left: 50%;
            bottom: 18px;
            transform: translateX(-50%);
            z-index: 11;
            border-radius: 999px;
            border: 1px solid rgba(255, 214, 138, 0.24);
            background: rgba(30, 23, 12, 0.86);
            color: #fff1d2;
            padding: 10px 14px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 170ms ease;
            pointer-events: none;
        }

        #toast.show { opacity: 1; }

        @media (max-width: 900px) {
            .controls {
                grid-template-columns: 1fr 1fr;
                align-items: stretch;
            }

            .controls input {
                grid-column: 1 / -1;
            }
        }
    </style>
</head>
<body>
    <div id="scene"></div>

    <div class="hud">
        <section class="panel">
            <div class="title">SkyHi Immersive Receiver</div>
            <div class="subtitle">Night sky portal with live arriving lanterns</div>
            <div class="controls">
                <input id="roomInput" type="text" inputmode="numeric" pattern="[0-9]{3,6}" maxlength="6" placeholder="Sky PIN (3-6 digits)">
                <button id="watchBtn" type="button">Watch Sky</button>
                <button id="stopBtn" type="button">Stop</button>
                <a class="link-btn" href="./index.html">Back</a>
            </div>
            <div id="status" class="status">Idle. Enter a Sky PIN and tap Watch Sky.</div>
            <div class="legend">
                <span><i class="dot gold"></i>Normal Lantern</span>
                <span><i class="dot rose"></i>Love Lantern</span>
                <span id="countLabel">Lanterns in sky: 0</span>
            </div>
        </section>
    </div>

    <div id="toast"></div>
    <audio id="bgMusic" src="./Background.mp3" preload="auto" autoplay loop playsinline hidden></audio>

    <link rel="icon" href="data:,">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        const SUPABASE_URL = 'https://pmsvailryexqutzvzcsd.snapcloud.dev';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc3ZhaWxyeWV4cXV0enZ6Y3NkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5MzI3MzMsImV4cCI6MjA4MjUwODczM30.WTvkWsgBddhUPvTYhG6NIBR697Csb4mPzrbR5nUDRbs';

        const roomInput = document.getElementById('roomInput');
        const watchBtn = document.getElementById('watchBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusEl = document.getElementById('status');
        const countLabel = document.getElementById('countLabel');
        const toastEl = document.getElementById('toast');
        const bgMusic = document.getElementById('bgMusic');
        const receivePinKey = 'skyhi_receive_pin';

        const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        let subChannel = null;
        let activePin = '';

        let renderer, scene, camera, clock;
        let starPoints, fireflyPoints, skyAura;
        const lanterns = [];
        const queue = [];
        const seenIds = new Set();
        let lastSpawn = 0;
        const maxLanterns = 40;
        const modelCache = { normal: null, heart: null };
        let particleTexture = null;

        function setStatus(text, isError) {
            statusEl.textContent = text;
            statusEl.style.color = isError ? '#ffd6d6' : 'rgba(255, 232, 194, 0.9)';
        }

        function toast(text) {
            toastEl.textContent = text;
            toastEl.classList.add('show');
            setTimeout(() => toastEl.classList.remove('show'), 2200);
        }

        function updateCount() {
            countLabel.textContent = 'Lanterns in sky: ' + lanterns.length;
        }

        function parseRow(row) {
            if (!row || !row.id) return null;
            const pin = String(row.room_id || '');
            if (!/^[0-9]{3,6}$/.test(pin)) return null;
            return {
                id: String(row.id),
                pin,
                sender: String(row.sender_name || 'Anonymous').trim() || 'Anonymous',
                text: String(row.message_text || '').trim(),
                shapeType: Number(row.shape_type) === 1 ? 1 : 0,
                createdAt: row.created_at || new Date().toISOString()
            };
        }

        function getParticleTexture() {
            if (particleTexture) return particleTexture;
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.35, 'rgba(255,255,255,0.9)');
            g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 64, 64);
            particleTexture = new THREE.CanvasTexture(canvas);
            return particleTexture;
        }

        function getGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            g.addColorStop(0, 'rgba(255, 214, 130, 1)');
            g.addColorStop(0.4, 'rgba(255, 188, 90, 0.45)');
            g.addColorStop(1, 'rgba(255, 160, 60, 0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 256, 256);
            return new THREE.CanvasTexture(canvas);
        }

        function createPointCloud(count, radius, color, size, opacity, yMin, yMax) {
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const r = radius * (0.3 + Math.random() * 0.7);
                const a = Math.random() * Math.PI * 2;
                const h = yMin + Math.random() * (yMax - yMin);
                positions[i * 3] = Math.cos(a) * r;
                positions[i * 3 + 1] = h;
                positions[i * 3 + 2] = -Math.sin(a) * r - Math.random() * 6.2;
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const circle = getParticleTexture();
            const mat = new THREE.PointsMaterial({
                color,
                size,
                map: circle,
                alphaMap: circle,
                transparent: true,
                opacity,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            return new THREE.Points(geo, mat);
        }

        function createMessageCard(sender, message, isLove) {
            const canvas = document.createElement('canvas');
            canvas.width = 768;
            canvas.height = 420;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = isLove ? 'rgba(64,22,30,0.82)' : 'rgba(30,22,12,0.82)';
            ctx.strokeStyle = isLove ? 'rgba(255,193,208,0.82)' : 'rgba(255,219,152,0.82)';
            ctx.lineWidth = 4;
            rounded(ctx, 10, 10, canvas.width - 20, canvas.height - 20, 28);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = isLove ? '#ffe8ef' : '#fff0cd';
            ctx.font = '700 40px Segoe UI';
            ctx.fillText((sender || 'Anonymous').slice(0, 30) + ' :', 36, 72);

            ctx.fillStyle = isLove ? '#fff3f6' : '#fff8e8';
            ctx.font = '500 33px Segoe UI';
            const lines = wrap(ctx, (message || '').slice(0, 300), canvas.width - 72);
            for (let i = 0; i < Math.min(lines.length, 6); i++) {
                ctx.fillText(lines[i], 36, 126 + i * 42);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            const mat = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthWrite: false,
                depthTest: false
            });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(1.45, 0.8, 1);
            sprite.renderOrder = 20;
            return sprite;
        }

        function rounded(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        function wrap(ctx, text, maxWidth) {
            if (!text) return ['(empty message)'];
            const words = text.split(/\s+/);
            const lines = [];
            let line = '';
            for (const word of words) {
                const t = line ? line + ' ' + word : word;
                if (ctx.measureText(t).width > maxWidth && line) {
                    lines.push(line);
                    line = word;
                } else {
                    line = t;
                }
            }
            if (line) lines.push(line);
            return lines;
        }

        function markModelMaterials(root, isLove) {
            root.traverse(obj => {
                if (!obj.isMesh) return;
                if (obj.material && obj.material.clone) {
                    obj.material = obj.material.clone();
                } else {
                    obj.material = new THREE.MeshStandardMaterial({ color: 0xffffff });
                }
                // Preserve original model color/look; only apply a subtle emissive lift.
                if (obj.material.emissive) {
                    const boost = isLove ? new THREE.Color(0xff879f) : new THREE.Color(0xf2b24f);
                    obj.material.emissive.add(boost.multiplyScalar(0.06));
                }
                obj.material.emissiveIntensity = Math.max(obj.material.emissiveIntensity || 0, 0.06);
                obj.castShadow = false;
                obj.receiveShadow = false;
            });
        }

        function makeString() {
            const points = [new THREE.Vector3(0, -0.15, 0), new THREE.Vector3(0, -0.78, 0)];
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: 0xf8dca5, transparent: true, opacity: 0.72 });
            return new THREE.Line(geo, mat);
        }

        async function loadModel(path) {
            return await new Promise((resolve, reject) => {
                const loader = new GLTFLoader();
                loader.load(path, gltf => resolve(gltf.scene), undefined, err => reject(err));
            });
        }

        async function loadLanternModels() {
            try {
                const [normal, heart] = await Promise.all([
                    loadModel('./models/Normal.glb'),
                    loadModel('./models/Heart.glb')
                ]);
                modelCache.normal = normal;
                modelCache.heart = heart;
                setStatus('Models loaded. Ready to watch skies.', false);
            } catch (err) {
                setStatus('Model load failed. Using fallback lanterns.', true);
            }
        }

        function fallbackLantern(isLove) {
            const group = new THREE.Group();
            const color = isLove ? 0xff9bb0 : 0xf6c16a;
            const geo = new THREE.CylinderGeometry(0.17, 0.2, 0.32, 18, 1, true);
            const mat = new THREE.MeshStandardMaterial({
                color,
                emissive: color,
                emissiveIntensity: 0.28,
                transparent: true,
                opacity: 0.9
            });
            group.add(new THREE.Mesh(geo, mat));
            return group;
        }

        function buildLantern(entry, markLive) {
            const isLove = entry.shapeType === 1;
            const root = new THREE.Group();

            let model;
            if (isLove && modelCache.heart) {
                model = modelCache.heart.clone(true);
            } else if (!isLove && modelCache.normal) {
                model = modelCache.normal.clone(true);
            } else {
                model = fallbackLantern(isLove);
            }
            markModelMaterials(model, isLove);
            const box = new THREE.Box3().setFromObject(model);
            const size = new THREE.Vector3();
            box.getSize(size);
            const desiredHeight = 0.95;
            const safeHeight = Math.max(size.y || 0, 0.0001);
            const uniformScale = desiredHeight / safeHeight;
            model.scale.setScalar(uniformScale);
            model.position.y = 0;
            root.add(model);

            const stringLine = makeString();
            root.add(stringLine);

            const card = createMessageCard(entry.sender, entry.text, isLove);
            card.position.set(0, -0.98, 0);
            root.add(card);

            const glowColor = isLove ? 0xff9aae : 0xffcc79;
            const light = new THREE.PointLight(glowColor, 1.25, 3.8, 1.7);
            root.add(light);

            const lane = lanterns.length;
            const side = lane % 2 === 0 ? -1 : 1;
            const band = Math.floor(lane / 2) % 6;
            const target = new THREE.Vector3(
                side * (0.95 + band * 0.28 + Math.random() * 0.16),
                1.35 + (lane % 3) * 0.08 + Math.random() * 0.05,
                -1.7 - band * 0.36 - Math.random() * 0.24
            );
            const start = new THREE.Vector3(target.x + (Math.random() - 0.5) * 1.5, 4.4 + Math.random() * 1.6, target.z + 1.2);
            root.position.copy(start);
            root.rotation.y = Math.random() * Math.PI * 2;
            scene.add(root);

            const now = performance.now();
            lanterns.push({
                id: entry.id,
                root,
                card,
                light,
                start,
                target,
                spawnAt: now,
                landAt: null,
                phase: Math.random() * Math.PI * 2,
                liveUntil: markLive ? now + 2500 : 0
            });

            if (markLive) toast('New lantern from ' + entry.sender);

            if (lanterns.length > maxLanterns) {
                const old = lanterns.shift();
                if (old && old.root) {
                    scene.remove(old.root);
                }
            }
            updateCount();
        }

        function queueLantern(msg, markLive) {
            if (!msg || seenIds.has(msg.id)) return;
            seenIds.add(msg.id);
            queue.push({ msg, markLive: !!markLive });
        }

        function clearLanternScene() {
            for (const item of lanterns) {
                if (item && item.root) {
                    scene.remove(item.root);
                }
            }
            lanterns.length = 0;
            queue.length = 0;
            seenIds.clear();
            updateCount();
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.09);

            camera = new THREE.PerspectiveCamera(56, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.65, 3.3);
            camera.lookAt(0, 1.2, -1.9);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.setClearColor(0x050505, 1);
            document.getElementById('scene').appendChild(renderer.domElement);

            clock = new THREE.Clock();

            scene.add(new THREE.HemisphereLight(0x9ab3d2, 0x1c1308, 0.5));
            const key = new THREE.DirectionalLight(0xffdca2, 0.55);
            key.position.set(2.2, 4.4, 1.6);
            scene.add(key);

            const dome = new THREE.Mesh(
                new THREE.SphereGeometry(26, 42, 32),
                new THREE.MeshBasicMaterial({ color: 0x090909, side: THREE.BackSide })
            );
            scene.add(dome);

            skyAura = new THREE.Sprite(
                new THREE.SpriteMaterial({
                    map: getGlowTexture(),
                    color: 0xffc66f,
                    transparent: true,
                    opacity: 0.14,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                })
            );
            skyAura.scale.set(13.5, 10.5, 1);
            skyAura.position.set(0, 2.1, -5.8);
            scene.add(skyAura);

            starPoints = createPointCloud(1700, 20, 0xffe1a8, 0.018, 0.92, -3.1, 3.4);
            fireflyPoints = createPointCloud(380, 12, 0xffbe6a, 0.09, 0.42, -2.6, 3.0);
            scene.add(starPoints);
            scene.add(fireflyPoints);
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = performance.now();
            const dt = clock.getDelta();

            skyAura.material.opacity = 0.07 + Math.sin(t * 0.00033) * 0.025;
            starPoints.rotation.y += dt * 0.004;
            fireflyPoints.rotation.y -= dt * 0.012;
            fireflyPoints.rotation.x += dt * 0.004;

            if (queue.length > 0 && t - lastSpawn > 700) {
                const next = queue.shift();
                buildLantern(next.msg, next.markLive);
                lastSpawn = t;
            }

            for (const l of lanterns) {
                const elapsed = t - l.spawnAt;
                if (!l.landAt) {
                    const p = Math.min(elapsed / 2600, 1);
                    const eased = 1 - Math.pow(1 - p, 3);
                    l.root.position.lerpVectors(l.start, l.target, eased);
                    l.root.rotation.z = Math.sin(elapsed * 0.0018 + l.phase) * 0.1 * (1 - eased * 0.6);
                    if (p >= 1) l.landAt = t;
                } else {
                    const d = (t - l.landAt) * 0.001;
                    l.root.position.y = l.target.y + Math.sin(d * 0.7 + l.phase) * 0.06;
                    l.root.position.x = l.target.x + Math.sin(d * 0.42 + l.phase) * 0.04;
                    l.root.rotation.z = Math.sin(d * 0.85 + l.phase) * 0.045;
                l.card.material.opacity = 0.86 + Math.sin(d * 0.55) * 0.08;
                }

                l.light.intensity = 1.0 + Math.sin(t * 0.006 + l.phase) * 0.25;
            }

            renderer.render(scene, camera);
        }

        async function stopWatching() {
            if (subChannel) {
                try { await supabaseClient.removeChannel(subChannel); } catch (_) {}
            }
            subChannel = null;
            activePin = '';
            setStatus('Stopped. Enter a Sky PIN and tap Watch Sky.', false);
        }

        async function watchSky(pin) {
            if (!/^[0-9]{3,6}$/.test(pin)) {
                setStatus('Sky PIN must be 3 to 6 digits.', true);
                return;
            }
            await stopWatching();
            clearLanternScene();
            activePin = pin;
            roomInput.value = pin;
            localStorage.setItem(receivePinKey, pin);
            setStatus('Loading Sky ' + pin + '...', false);

            try {
                const { data, error } = await supabaseClient
                    .from('lanterns')
                    .select('id, room_id, message_text, sender_name, shape_type, created_at')
                    .eq('room_id', pin)
                    .order('created_at', { ascending: true })
                    .limit(40);
                if (error) throw error;

                for (const row of data || []) {
                    const parsed = parseRow(row);
                    if (parsed) queueLantern(parsed, false);
                }

                subChannel = supabaseClient
                    .channel('skyhi-immersive-' + pin + '-' + Date.now())
                    .on('postgres_changes', {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'lanterns',
                        filter: 'room_id=eq.' + pin
                    }, payload => {
                        const parsed = parseRow(payload.new);
                        if (!parsed) return;
                        queueLantern(parsed, true);
                        setStatus('Live on Sky ' + pin + '. New lantern from ' + parsed.sender + '.', false);
                    })
                    .subscribe(status => {
                        if (status === 'SUBSCRIBED') {
                            setStatus('Live on Sky ' + pin + '. Awaiting lanterns.', false);
                        }
                    });
            } catch (err) {
                setStatus('Unable to watch Sky ' + pin + ': ' + (err && err.message ? err.message : String(err)), true);
            }
        }

        function initAudio() {
            if (!bgMusic) return;
            bgMusic.volume = 0.4;
            const resume = () => {
                const p = bgMusic.play();
                if (p && p.catch) p.catch(() => {});
            };
            resume();
            window.addEventListener('pointerdown', resume, { passive: true });
            window.addEventListener('keydown', resume, { passive: true });
        }

        function initEvents() {
            roomInput.addEventListener('input', () => {
                roomInput.value = roomInput.value.replace(/\D/g, '').slice(0, 6);
            });
            roomInput.addEventListener('keypress', e => {
                if (e.key === 'Enter') watchSky(roomInput.value.trim());
            });
            watchBtn.addEventListener('click', () => watchSky(roomInput.value.trim()));
            stopBtn.addEventListener('click', () => stopWatching());

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.addEventListener('pointermove', e => {
                const nx = (e.clientX / window.innerWidth) * 2 - 1;
                const ny = (e.clientY / window.innerHeight) * 2 - 1;
                camera.position.x = nx * 0.22;
                camera.position.y = 1.65 - ny * 0.08;
                camera.lookAt(0, 1.2, -1.9);
            });
        }

        async function boot() {
            initScene();
            initEvents();
            initAudio();
            animate();
            await loadLanternModels();

            const params = new URLSearchParams(window.location.search);
            const urlPin = params.get('pin');
            const persisted = localStorage.getItem(receivePinKey);
            const initial = (urlPin && /^[0-9]{3,6}$/.test(urlPin)) ? urlPin : persisted;
            if (initial) {
                roomInput.value = initial;
                watchSky(initial);
            }
        }

        boot();
    </script>
</body>
</html>
